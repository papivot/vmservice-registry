#!/bin/bash

set -euo pipefail

# --- Logging Functions ---
log_info() {
    echo "[INFO] $(date '+%Y-%m-%d %H:%M:%S') - $1"
}

log_warning() {
    echo "[WARN] $(date '+%Y-%m-%d %H:%M:%S') - $1"
}

log_error() {
    # Logs error to stderr
    echo "[ERROR] $(date '+%Y-%m-%d %H:%M:%S') - $1" >&2
}

trap 'log_error "Error occurred at line $LINENO. Exiting."; exit 1' ERR
trap cleanup EXIT

function cleanup {
    log_info "Cleaning up temporary files before exiting..."

    rm -f cloud-init.yaml htpasswd id_rsa id_rsa.pub
    # Handle cleanup of CERT_PATH and KEY_PATH carefully, especially if user-provided
    if [ "$CERT_CHOICE" == "n" ]; then # Only remove if generated by the script
        if [ -n "$CERT_PATH" ] && [ "$CERT_PATH" = "./domain.crt" ] && [ -f "$CERT_PATH" ]; then
             log_info "Removing generated certificate file: $CERT_PATH"
             rm -f "$CERT_PATH"
        fi
        if [ -n "$KEY_PATH" ] && [ "$KEY_PATH" = "./domain.key" ] && [ -f "$KEY_PATH" ]; then
            log_info "Removing generated key file: $KEY_PATH"
            rm -f "$KEY_PATH"
        fi
    else # User provided certs, do not remove them.
        log_info "User provided TLS certificate and key. These will not be removed by the script."
    fi
    log_info "Cleanup finished."
}

required_commands=("htpasswd" "openssl" "kubectl" "ssh" "scp" "base64" "tanzu")
for cmd in "${required_commands[@]}"; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
        log_error "$cmd CLI could not be found. Please install it."
        critical_error=1
    else
        log_info "$cmd CLI found."
    fi
done

#Check if these files are preset
if [ ! -f ./registry.tar ]; then
    log_error "registry.tar not found. Please ensure it is present in the current directory (created by 'docker save registry:2 -o registry.tar')."
    critical_error=1
else
    log_info "Required file registry.tar found."
fi
#harbor-image

if [ "$critical_error" -ne 0 ]; then
    log_error "Critical prerequisites missing. Please install/acquire them and retry."
    exit 1
fi

read -rp "Enter the VSPHERE NAMESPACE where the registry will be installed: " NAMESPACE
if [ -z "$NAMESPACE" ]; then
    log_error "Namespace cannot be empty."
    exit 1
fi
if ! [[ "$NAMESPACE" =~ ^[a-z0-9]([-a-z0-9]*[a-z0-9])?$ ]]; then
    log_error "Invalid Kubernetes Namespace: '${NAMESPACE}'. Must consist of lower case alphanumeric characters or '-', and must start and end with an alphanumeric character."
    exit 1
fi
log_info "Using VSPHERE NAMESPACE: ${NAMESPACE}"

log_info "--- Getting a valid Photon 5.0 VMI ---"
VMI_LIST=$(kubectl get vmi -n "${NAMESPACE}" -o jsonpath='{range .items[?(@.status.productInfo.version=="5.0")]}{.metadata.name}{" "}{end}')
# Count the number of VMIs found
IFS=' ' read -r -a VMI_ARRAY <<< "$VMI_LIST"
NUM_VMIS=${#VMI_ARRAY[@]}

if [ "$NUM_VMIS" -eq 0 ]; then
    log_error "No Photon 5.0 VMI found in namespace '${NAMESPACE}'. Please ensure a valid Photon 5.0 VMI is available."
    exit 1
elif [ "$NUM_VMIS" -gt 1 ]; then
    log_error "Multiple Photon 5.0 VMIs found in namespace '${NAMESPACE}': ${VMI_LIST}"
    log_error "Please ensure only one relevant Photon 5.0 VMI exists or refine the selection criteria in the script."
    exit 1
else
    VMI="${VMI_ARRAY[0]}"
    log_info "Using Photon 5.0 VMI: ${VMI}"
fi

read -rp "Enter the STORAGECLASS where the registry will be installed: " STORAGECLASS
if [ -z "$STORAGECLASS" ]; then
    log_error "storageClass cannot be empty."
    exit 1
fi
if ! [[ "$STORAGECLASS" =~ ^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$ ]]; then
    # This regex is a common one for K8s names, allowing for domain-like prefixes too.
    log_error "Invalid Kubernetes StorageClass name: '${STORAGECLASS}'. Generally, it consists of lower case alphanumeric characters, '-', or '.', and must start and end with an alphanumeric character."
    exit 1
fi
log_info "Using STORAGECLASS: ${STORAGECLASS}"

# Get hostname
read -rp "Enter the HOSTNAME of the registry (e.g. registry.example.com): " HOSTNAME
if [ -z "$HOSTNAME" ]; then
    log_error "Hostname cannot be empty."
    exit 1
fi
if ! [[ "$HOSTNAME" =~ ^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$ ]]; then
    log_error "Invalid hostname format: '${HOSTNAME}'. Hostname should be like 'registry.example.com'."
    exit 1
fi
log_info "Using HOSTNAME: ${HOSTNAME}"

# Get credentials and create htpasswd manually
read -rp "Enter the USERNAME that will be used to push images to the registry: " USER
if [ -z "$USER" ]; then
    log_error "Username cannot be empty."
    exit 1
fi
read -s -rp "Enter the PASSWORD for the above user: " PASS
echo
if [ -z "$PASS" ]; then
    log_error "Password cannot be empty."
    exit 1
fi
log_info "Registry credentials for USER='${USER}' collected." # PASS variable is not logged here.
HTPASSWD_FILE="./htpasswd"
if ! htpasswd -Bb -C 10 -c ${HTPASSWD_FILE} "${USER}" "${PASS}"; then
    log_error "Failed to create htpasswd file using 'htpasswd -Bb -C 10 -c ${HTPASSWD_FILE} ${USER} ***'."
    exit 1
fi

# Ask for cert/key or generate
read -rp "Will you provide TLS cert and key files? (y/n): " CERT_CHOICE_INPUT
CERT_CHOICE=$(echo "$CERT_CHOICE_INPUT" | tr '[:upper:]' '[:lower:]') # Normalize to lowercase

if [[ ! "$CERT_CHOICE" =~ ^[yn]$ ]]; then
    log_error "Invalid choice for TLS: '${CERT_CHOICE_INPUT}'. Please enter 'y' or 'n'."
    exit 1
fi

log_info "--- Creating Kubernetes PersistentVolumeClaim (PVC) ---"
log_info "Applying PersistentVolumeClaim definition 'vmware-docker-registry-pvc' in namespace '${NAMESPACE}' using StorageClass '${STORAGECLASS}'..."
cat <<EOF | kubectl apply -n "${NAMESPACE}" -f -
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: vmware-docker-registry-pvc
  labels:
    vm-selector: vmware-docker-registry
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 3Gi
  storageClassName: "${STORAGECLASS}"
  volumeMode: Filesystem
EOF
log_info "Successfully applied PersistentVolumeClaim vmware-docker-registry-pvc"
log_info "--- Kubernetes PVC Creation Complete ---"

log_info "--- Creating Kubernetes VirtualMachineService (LoadBalancer) ---"
log_info "Applying VirtualMachineService definition 'vmware-docker-registry-vmservices' in namespace '${NAMESPACE}'..."
# Deploy a LoadBalancer service and fetch external IP
cat <<EOF | kubectl apply -n "${NAMESPACE}" -f -
apiVersion: vmoperator.vmware.com/v1alpha1
kind: VirtualMachineService
metadata:
  name: vmware-docker-registry-vmservices
spec:
  ports:
  - name: https
    port: 443
    protocol: TCP
    targetPort: 5000
  - name: ssh
    port: 22
    protocol: TCP
    targetPort: 22
  selector:
    vm-selector: vmware-docker-registry
  type: LoadBalancer
EOF
log_info "VirtualMachineService vmware-docker-registry-vmservices created. Waiting for LoadBalancer to be assigned an external IP..."

# Wait for the LoadBalancer to get an external IP
for i in {1..60}; do
    EXTERNAL_IP=$(kubectl get svc -n "${NAMESPACE}" vmware-docker-registry-vmservices -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || true)
    if [ -n "$EXTERNAL_IP" ]; then
        log_info "LoadBalancer external IP assigned: $EXTERNAL_IP"
        break
    fi
    sleep 5
    log_info "Waiting for LoadBalancer to be assigned an external IP... attempt: $i"
done

if [ -z "$EXTERNAL_IP" ]; then
    log_error "Failed to get external IP for LoadBalancer 'vmware-docker-registry-vmservices' after 60 attempts."
    exit 1
fi
log_info "--- Kubernetes VirtualMachineService Creation and IP Retrieval Complete ---"

if [ "$CERT_CHOICE" == "y" ]; then
    read -rp "Enter the path to your TLS certificate file (e.g., domain.crt): " USER_CERT_PATH
    if [ -z "$USER_CERT_PATH" ]; then
        log_error "Certificate file path cannot be empty."
        exit 1
    fi
    if [ ! -f "$USER_CERT_PATH" ]; then
        log_error "Certificate file not found at: $USER_CERT_PATH"
        exit 1
    fi
    CERT_PATH="$USER_CERT_PATH"
    log_info "Using user-provided certificate file: $CERT_PATH"

    read -rp "Enter the path to your TLS key file (e.g., domain.key): " USER_KEY_PATH
    if [ -z "$USER_KEY_PATH" ]; then
        log_error "Key file path cannot be empty."
        exit 1
    fi
    if [ ! -f "$USER_KEY_PATH" ]; then
        log_error "Key file not found at: $USER_KEY_PATH"
        exit 1
    fi
    KEY_PATH="$USER_KEY_PATH" # Set global
    log_info "Using user-provided key file: $KEY_PATH"
else
    log_info "Generating self-signed TLS certificate for Hostname: $HOSTNAME and IP: $EXTERNAL_IP..."
    CERT_PATH="./domain.crt"
    KEY_PATH="./domain.key"
    openssl req -x509 -nodes -days 365 -newkey rsa:4096 \
        -keyout "$KEY_PATH" \
        -out "$CERT_PATH" \
        -subj "/CN=$HOSTNAME" \
        -addext "subjectAltName=DNS:$HOSTNAME,IP:$EXTERNAL_IP" >/dev/null 2>&1
    log_info "Self-signed TLS certificate and key generated successfully: $CERT_PATH, $KEY_PATH"
    # Set secure permissions for the generated private key
    if ! chmod 600 "$KEY_PATH"; then
        log_warning "Failed to set permissions (0600) on generated key file: $KEY_PATH. Continuing, but this is a security concern."
    else
        log_info "Permissions set to 0600 for generated key file: $KEY_PATH"
    fi
fi
log_info "--- TLS Certificate Handling Complete ---"

log_info "--- Creating Kubernetes TLS Secret ---"
log_info "Checking for existing TLS secret vmware-docker-registry-tls-secret in namespace '${NAMESPACE}'..."
if kubectl get secret vmware-docker-registry-tls-secret -n "${NAMESPACE}" &>/dev/null; then
    log_warning "Secret vmware-docker-registry-tls-secret already exists. Deleting it..."
    if ! kubectl delete secret vmware-docker-registry-tls-secret -n "${NAMESPACE}"; then
        log_error "Failed to delete existing TLS secret vmware-docker-registry-tls-secret'. Please check permissions or delete manually."
        # Not exiting, as create might still work or fail with a clearer message from kubectl
    else
        log_info "Existing TLS secret vmware-docker-registry-tls-secret deleted."
    fi
fi
log_info "Creating TLS secret vmware-docker-registry-tls-secret using cert='${CERT_PATH}' and key='${KEY_PATH}'..."
if ! kubectl create secret tls vmware-docker-registry-tls-secret --cert="$CERT_PATH" --key="$KEY_PATH" -n "${NAMESPACE}"; then
    log_error "Failed to create TLS secret vmware-docker-registry-tls-secret. Ensure cert/key paths are correct and valid."
    exit 1
fi
log_info "TLS secret vmware-docker-registry-tls-secret created successfully."
log_info "--- Kubernetes TLS Secret Creation Complete ---"

# Base64 encode files
HTPASSWD_B64=$(base64 -w 0 "$HTPASSWD_FILE")
CERT_B64=$(base64 -w 0 "$CERT_PATH")
KEY_B64=$(base64 -w 0 "$KEY_PATH")

log_info "--- Generating and Creating Kubernetes SSH Secret ---"
log_info "Generating 4096-bit RSA SSH key pair at id_rsa (private) and id_rsa.pub (public)..."
rm -f ./id_rsa ./id_rsa.pub
if ! ssh-keygen -t rsa -b 4096 -f ./id_rsa -N "" >/dev/null 2>&1; then
    log_error "Failed to generate SSH key pair using ssh-keygen."
    exit 1
fi
chmod 600 ./id_rsa
log_info "Set permissions for ./id_rsa to 600."
SSH_PUB_KEY=$(cat ./id_rsa.pub || echo '')
if [ -z "$SSH_PUB_KEY" ]; then
    log_error "SSH public key file id_rsa.pub is empty or not found after generation."
    exit 1
fi
log_info "SSH key pair generated successfully."

# Create SSH secret
log_info "Checking for existing SSH secret vmware-docker-registry-ssh-secret in namespace '${NAMESPACE}'..."
if kubectl get secret vmware-docker-registry-ssh-secret -n "${NAMESPACE}" &>/dev/null; then
    log_warning "Secret vmware-docker-registry-ssh-secret already exists. Deleting it..."
    if ! kubectl delete secret vmware-docker-registry-ssh-secret -n "${NAMESPACE}"; then
        log_error "Failed to delete existing SSH secret vmware-docker-registry-ssh-secret."
    else
        log_info "Existing SSH secret vmware-docker-registry-ssh-secret deleted."
    fi
fi
log_info "Creating SSH secret 'vmware-docker-registry-ssh-secret from generated keys..."
if ! kubectl create secret generic vmware-docker-registry-ssh-secret --from-file=ssh-privatekey=./id_rsa --from-file=ssh-publickey=./id_rsa.pub -n "${NAMESPACE}"; then
    log_error "Failed to create SSH secret vmware-docker-registry-ssh-secret."
    exit 1
fi
log_info "SSH secret vmware-docker-registry-ssh-secret created successfully."
log_info "--- Kubernetes SSH Secret Creation Complete ---"

log_info "--- Generating cloud-init Configuration ---"
# Generate cloud-init YAML
cat <<EOF > cloud-init.yaml
#cloud-config

users:
  - name: vmware-system-user
    gecos: VMware System User  
    sudo: ALL=(ALL) NOPASSWD:ALL
    groups: users, admin, sudo
    shell: /bin/bash
    ssh_authorized_keys:
      - $SSH_PUB_KEY

ssh:
  emit_keys_to_console: false

disk_setup:
  /dev/sdb:
    table_type: gpt
    layout: True
    overwrite: True

fs_setup:
  - device: /dev/sdb
    filesystem: ext4
    partition: 1

mounts:
  - [ /dev/sdb1, /opt/registry/data, "auto", "defaults,noexec,nofail" ]

write_files:
  - path: /opt/registry/auth/htpasswd.b64
    permissions: '0644'
    content: |
      $(echo "$HTPASSWD_B64")

  - path: /opt/registry/certs/domain.crt.b64
    permissions: '0644'
    content: |
      $(echo "$CERT_B64")

  - path: /opt/registry/certs/domain.key.b64
    permissions: '0600'
    content: |
      $(echo "$KEY_B64")

  - path: /opt/registry/start-registry.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      
      echo "[INFO] Loading registry image"
      docker load -i /opt/registry/registry.tar

      echo "[INFO] Creating directories"
      mkdir -p /opt/registry/data

      echo "[INFO] Starting Docker Registry"
      docker run -d --restart=always --name registry \
        -p 5000:5000 \
        -v /opt/registry/data:/var/lib/registry \
        -v /opt/registry/auth:/auth \
        -v /opt/registry/certs:/certs \
        -e REGISTRY_HTTP_ADDR=0.0.0.0:5000 \
        -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/domain.crt \
        -e REGISTRY_HTTP_TLS_KEY=/certs/domain.key \
        -e REGISTRY_AUTH=htpasswd \
        -e REGISTRY_AUTH_HTPASSWD_REALM="Registry Realm" \
        -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \
        registry:2

      echo "[INFO] Waiting for registry to be ready..."
      sleep 10

runcmd:
  - systemctl enable docker
  - systemctl restart docker
  - systemctl restart sshd
  - chown -R vmware-system-user:users /opt/registry
  - usermod -aG docker vmware-system-user
  - base64 -d /opt/registry/auth/htpasswd.b64 > /opt/registry/auth/htpasswd
  - base64 -d /opt/registry/certs/domain.crt.b64 > /opt/registry/certs/domain.crt
  - base64 -d /opt/registry/certs/domain.key.b64 > /opt/registry/certs/domain.key
  - chmod 600 /opt/registry/auth/htpasswd
  - chmod 644 /opt/registry/certs/domain.crt
  - chmod 600 /opt/registry/certs/domain.key
EOF

log_info "Generated cloud-init.yaml"
log_info "--- cloud-init Configuration Generation Complete ---"

log_info "--- Creating Kubernetes ConfigMap for cloud-init ---"
# Deploy ConfigMap with encoded CloudInit
log_info "Encoding '${cloud_init_file}' to Base64..."
CLOUDINIT_B64=$(base64 -w 0 ./cloud-init.yaml)
if [ -z "$CLOUDINIT_B64" ]; then
    log_error "Failed to encode cloud-init.yaml to Base64 or file is empty."
    exit 1
fi

cat <<EOF | kubectl apply -n "${NAMESPACE}" -f -
apiVersion: v1
kind: ConfigMap
metadata:
    name: vmware-docker-registry-configmap
data:
  hostname: ${HOSTNAME}
  public-keys: ${SSH_PUB_KEY}
  user-data: ${CLOUDINIT_B64}
EOF
log_info "Successfully applied ConfigMap vmware-docker-registry-configmap."
log_info "--- Kubernetes ConfigMap Creation Complete ---"

log_info "--- Deploying Kubernetes VirtualMachine ---"
log_info "Applying VirtualMachine definition vmware-docker-registry in namespace '${NAMESPACE}'..."
cat <<EOF | kubectl apply -n "${NAMESPACE}" -f -
apiVersion: vmoperator.vmware.com/v1alpha1
kind: VirtualMachine
metadata:
  labels:
    vm-selector: vmware-docker-registry
  name: vmware-docker-registry-vm
spec:
  imageName: "${VMI}"
  className: best-effort-xsmall
  powerState: poweredOn
  storageClass: "${STORAGECLASS}"
  advancedOptions:
    defaultVolumeProvisioningOptions:
      thinProvisioned: true
  volumes:
  - name: registry-vol
    persistentVolumeClaim:
      claimName: vmware-docker-registry-pvc
  readinessProbe:
    tcpSocket:
      port: 22
  vmMetadata:
    configMapName: vmware-docker-registry-configmap
    transport: CloudInit
EOF

#wait for VM to be ready
log_info "VM vmware-docker-registry reported IP ${EXTERNAL_IP}. Now checking SSH port 22 responsiveness..."
while ! timeout 5 bash -c "</dev/tcp/${EXTERNAL_IP}/22" > /dev/null 2>&1; do
    log_info "VM SSH port 22 not ready yet at ${EXTERNAL_IP}. Waiting..."
    sleep 30
done
log_info "VM SSH port 22 is responsive on ${EXTERNAL_IP}."
log_info "Removing existing SSH known_hosts entry for ${EXTERNAL_IP} to prevent man-in-the-middle warnings on re-runs."
ssh-keygen -f ~/.ssh/known_hosts -R "${EXTERNAL_IP}" >/dev/null 2>&1

log_info "VM is ready. Proceeding with copying files and executing setup script on the VM..."
log_info "Copying 'registry.tar' to the VM at /opt/registry/ via scp..."
scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i ./id_rsa ./registry.tar vmware-system-user@"${EXTERNAL_IP}":/opt/registry/
log_info "Executing '/opt/registry/start-registry.sh' script on the VM via ssh..."
ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i ./id_rsa vmware-system-user@"${EXTERNAL_IP}" 'bash /opt/registry/start-registry.sh'
log_info "Successfully executed 'start-registry.sh' on the VM. Registry setup process initiated on VM."
log_info "--- VM Setup and Registry Initialization Complete ---"

# Validate registry availability with HTTP 200 response
log_info "--- Validating Docker Registry ---"
log_info "Validating registry is responding on https://${EXTERNAL_IP}/v2/_catalog (expecting HTTP 401 Unauthorized)..."
for i in {1..10}; do
  STATUS=$(curl -ks -o /dev/null -w "%{http_code}" https://"${EXTERNAL_IP}"/v2/_catalog || true)
  if [[ "$STATUS" == "401" ]]; then
    log_info "Registry is up and returned HTTP 401 Unauthorized. This is expected as we have not authenticated to the registry."
    break
  fi
  log_info "Waiting for registry... ($i)"
  sleep 5
done
log_info "--- Docker Registry Validation Successful ---"

# Upload OCI tarball using imgpkg
#if [[ -f ./harbor-bundle.tar ]]; then
#  echo "Uploading OCI image using imgpkg..."
#  imgpkg copy --tar /opt/registry/harbor-bundle.tar --to-repo "${EXTERNAL_IP}"/harbor-bundle --registry-ca-cert-path /certs/domain.crt --registry-username $USER --registry-password $PASS || echo "Failed to upload image"
#fi
#echo "Deployment script completed successfully."
